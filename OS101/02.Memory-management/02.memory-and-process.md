# Memory and Process
Earlier, we have introduced the concept of process. Which is a program in execution. When you run a program, the os will map the program intro memory as a process. Which consist of data, code, stack, and heap. In this lesson, we will delve into each section in the process in details.

![process in memory](./images/04.process.png)


## Process Memory Sections
When a process is loaded into memory, it is organized into several distinct sections, each serving a specific purpose. These sections are the **code**, **data**, **heap**, and **stack**. Letâ€™s explore each section in detail:

### 1. Code Section

#### Description
The **code section** (or text segment) contains the compiled executable code of the program. This is the actual machine code that the CPU executes. It's typically read-only to prevent modification during execution, ensuring the integrity of the program.

#### Storage
- **Location**: The code section is loaded into a fixed area of memory when the process starts.
- **Access**: The CPU fetches instructions from this section to execute them.

#### Example
Consider the following simple C program:

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

When compiled, the machine code corresponding to the `main` function and the `printf` call resides in the code section.

### 2. Data Section

#### Description
The **data section** contains global and static variables that are initialized by the programmer. Unlike the code section, this area is writable, allowing for modifications during execution.

#### Storage
- **Location**: It is typically located immediately after the code section in memory.
- **Initialized vs. Uninitialized**: This section can be further divided into initialized data (e.g., `int a = 10;`) and uninitialized data (e.g., `static int b;`).

#### Example
In the following code:

```c
int globalVar = 5; // Initialized global variable
static int staticVar; // Uninitialized static variable

int main() {
    return 0;
}
```

`globalVar` gets stored in the initialized part of the data section, while `staticVar` is stored in the uninitialized part.

### 3. Heap Section

#### Description
The **heap section** is used for dynamic memory allocation. This is where memory is allocated at runtime using functions like `malloc()` in C, or `new` in C++ and Java. The size of the heap can grow or shrink as needed, depending on the program's requirements.

#### Storage
- **Management**: The programmer is responsible for managing memory in this section, including freeing allocated memory to avoid memory leaks.

> Note: there is an issue called **memory leak**, it happens when an allocated memory address is no longer needed but was not deallocated. It decreases the performance of the computer since there is less space to be used in the memory.

#### Example
Consider the following example where memory is allocated dynamically:

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    int *array = malloc(10 * sizeof(int)); // Allocating memory for an array of 10 integers

    for (int i = 0; i < 10; i++) {
        array[i] = i * 2;
        printf(" Array[%d]: %d \n",i,array[i]); // Print array elements
    }

    free(array); // Freeing allocated memory
    return 0;
}
```

In this example, the memory for `array` is allocated on the heap since we determined its size at runtime.

### 4. Stack Section

#### Description
The **stack section** is used for function call management, including local variables and function parameters. Each time a function is called, a new stack frame is created to hold its local data and return address.

#### Storage
- **Location**: The stack grows downwards from higher memory addresses towards lower ones.
- **Automatic Management**: Memory on the stack is automatically managed; it is allocated when a function is called and deallocated when the function exits.

#### Example
Consider a function with local variables:

```c
#include <stdio.h>

void myFunction() {
    int localVar = 10; // Local variable stored on the stack
    printf("%d\n", localVar);
}

int main() {
    myFunction(); // Calling the function
    return 0;
}
```
In this example, `localVar` is stored in the stack section, and its memory is automatically freed when `myFunction` returns.

> Note: **Code Section** is specifically designed to hold executable instructions (machine code) of the program. The code section is where all function definitions, including `main`, are stored in a read-only format.

>Note: The **Stack** is used for managing function calls, local variables, and return addresses during program execution. It is a temporary storage area for data that needs to be accessed quickly and is automatically managed by the operating system.

### Summary

- **Code Section**: Contains the executable code; read-only during execution.
- **Data Section**: Holds global and static variables; writable.
- **Heap Section**: Used for dynamic memory allocation; managed by the programmer.
- **Stack Section**: Manages function calls and local variables; automatically managed.

Understanding how these sections are stored and managed is crucial for efficient programming and memory management in any application.



## Project
[project needed, I will give them a code snippet and ask where will some definitions get stored in process memory layout? ]