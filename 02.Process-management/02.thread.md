# Thread 


## Concept
Have you ever used a program running several tasks at the same time? for example a music player, it plays the music and in the same time it shows notification and displays recommendations. All of these tasks happen concurrently not sequentially. Also, the music player process is not utilizing another processes for other tasks but performs several tasks at the same time by it-self. This can be achieved via threads. 

A `thread` is a unit of execution. Every process has at least one thread to get executed. You can think of the thread as an execution arrow that reads instructions one after the other.
Having more than one thread in a single process means more independent execution units that can run concurrently at the same time.

[Image of the process that has one thread (main) and a process that has multiple threads (main, t0, t1)]

Threads are a small execution units inside of a process, and they share some resources as described in the image below.
[image of a closer look into a process with multiple threads and their shared and unshared resources.]


### Thread States
Threads go through a lifecycle that changes its state.

Thread states:
- **New** : new thread have been created.
- **Ready** : the thread is simply ready for running.
- **Running** : the thread is currently running.
- **Waiting** : the thread is waiting for a specific event to execute.
- **Blocked** : the thread got blocked while running for a specific reason. For example a sleep method have been executed, or it is waiting for an I/O device.
- **Dead/Terminated** : thread have been terminated.


## Code 
To handle threads, we will be working with `Thead` class and its related classes and interfaces to create, read, and delete threads.


### Create Thread

You can create a new thread by two ways. 
- Extending `Thread` class
```java
public class CreateThread1 {
    
    public static void main(String[] args) {
        Multithreading t0 = new Multithreading();
        t0.start();
    }
}

class Multithreading extends Thread{
    @Override
    public void run() {
        System.out.println( "Thread is running");
    }
}

```

> By extending `Thread` class, you can use its methods such as `start()` to run the thread after creating it. Otherwise the thread will not start running.

- Implementing `Runnable` interface
```java

public class CreateThread2 {
    
    public static void main(String[] args) {
        Multithreading runnableThread = new Multithreading();
        Thread t0 = new Thread(runnableThread);
        t0.start();
    }
}

class Multithreading implements Runnable{
    @Override
    public void run() {
        System.out.println( "Thread is running");
    }
}


```

There is a shortcut to implement an interface in java without the effort to create a class as the following.
```java
public class CreateThread2 {
    
    public static void main(String[] args) {
        
        Thread t0 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println( "Thread is running");
            }
        });
        t0.start();
    }
}

```

### Read Thread
Every process has at least one thread running (main). Let us first print the current running thread in a java program. 

```java
public class ReadThread1 {
    
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName()); //output: main
    }
}
```
To create another thread and read it, you can use the Thread class methods such as `getName()`.
```java
public class ReadThread2 {
    
    public static void main(String[] args) {
        Multithreading t0 = new Multithreading();
        t0.start();
    }
}

class Multithreading extends Thread{
    @Override
    public void run() {
        System.out.println( "Thread " + this.getName() + " is running");
    }
}

```

output
```
Thread Thread-0 is running
```

### Terminate Thread

```java
public class TerminateThread {
    
    public static void main(String[] args) throws InterruptedException {
        Multithreading t0 = new Multithreading();
        t0.start();
        System.out.println(t0.getState());
    }
}

class Multithreading extends Thread{
    @Override
    public void run() {
        System.out.println( "Thread " + this.getName() + " is running");
    }
}

```

output
```
RUNNABLE
Thread Thread-0 is running
```
As you can see, the RUNNABLE state was printed then the thread was executed. It did not terminate since the the time the print statement was executed the thread was ready for execution hence RUNNABLE. Lets wait for 3 seconds before printing the thread state now.

```java
public class TerminateThread2 {
    
    public static void main(String[] args) throws InterruptedException {
        Multithreading t0 = new Multithreading();
        t0.start();
        t0.sleep(3000);
        System.out.println(t0.getState());
    }
}

class Multithreading extends Thread{
    @Override
    public void run() {
        System.out.println( "Thread " + this.getName() + " is running");
    }
}

```

output
```
Thread Thread-0 is running
TERMINATED
```

we have given the thread the time to execute and terminate before printing its state. Therefore the current state of the thread is terminated.

## Resources
- [Runestone Academy](https://runestone.academy/ns/books/published/javajavajava/thread-statesand-life-cycle.html)
## Projects
